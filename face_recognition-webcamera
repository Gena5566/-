Загружает по ссылке датасет, который содержит папки девяти классов по три фотографии каждый. Датасет скачиваем с Google Drive на свой локальный компьютер, а затем указывоем путь к локальной директории, в которой хранятся скачанные изображения: Ссылка: 'https://drive.google.com/drive/folders/1YfwtxIkGGHO9aqczaJ_INskdZ5vdeJL_?usp=share_link' Указываем путь: /Users/n.a./Downloads/Piligrim.lite

import numpy as np
import face_recognition
import cv2
import os
from datetime import datetime
import os
​
path = '/Users/n.a./Downloads/Piligrim.lite'
images = []  # определяем список images
classNames = []
myList = os.listdir(path)
print(myList)
​
for cls in myList:
    curPath = os.path.join(path, cls)
    for img in os.listdir(curPath):
        curImg = cv2.imread(os.path.join(curPath, img))
        images.append(curImg)
        classNames.append(cls)
​
print(classNames)
#print(images)
​
['Person_8', 'Person_1', 'Person_6', 'Person_7', 'Person_9', 'Person_5', 'Person_2', 'Person_3', 'Person_4']
['Person_8', 'Person_8', 'Person_8', 'Person_1', 'Person_1', 'Person_1', 'Person_6', 'Person_6', 'Person_6', 'Person_7', 'Person_7', 'Person_7', 'Person_9', 'Person_9', 'Person_9', 'Person_5', 'Person_5', 'Person_5', 'Person_2', 'Person_2', 'Person_2', 'Person_3', 'Person_3', 'Person_3', 'Person_4', 'Person_4', 'Person_4']
1.import numpy as np: Этот оператор импортирует библиотеку NumPy, которая предоставляет функциональность для работы с многомерными массивами и матрицами в Python.
2.import face_recognition: Этот оператор импортирует библиотеку face_recognition, которая предоставляет возможности распознавания лиц на изображениях.
3.import cv2: Этот оператор импортирует библиотеку OpenCV, которая предоставляет функциональность для обработки изображений и видео.
4.import os: Этот оператор импортирует модуль os, который предоставляет функции для взаимодействия с операционной системой, включая работу с файлами и директориями.
5.from datetime import datetime: Этот оператор импортирует класс datetime из модуля datetime. Он используется для работы с датой и временем.
6.path = '/Users/n.a./Downloads/Piligrim.lite': Эта строка определяет переменную path, которая содержит путь к локальной директории, где хранятся изображения. Здесь указан путь /Users/n.a./Downloads/Piligrim.lite, но вам нужно заменить его на фактический путь к вашей директории с изображениями.
7.images = []: Эта строка создает пустой список images, в который будут добавляться изображения.
8.classNames = []: Эта строка создает пустой список classNames, в который будут добавляться имена классов.
9.myList = os.listdir(path): Эта строка использует функцию listdir модуля os для получения списка файлов и директорий в указанной директории path и сохраняет его в переменной myList.
10.print(myList): Эта строка выводит список файлов и директорий в директории path на консоль.
11.for cls in myList:: Эта строка начинает цикл for, который проходит через каждый элемент в списке myList и сохраняет его в переменную cls. Каждый элемент в списке представляет имя класса или название директории.
12.curPath = os.path.join(path, cls): Эта строка создает путь к текущей директории, объединяя базовый путь path и имя класса cls.
13.for img in os.listdir(curPath): Эта строка начинает вложенный цикл for, который проходит через каждый элемент в списке файлов и директорий в текущей директории curPath.
14.curImg = cv2.imread(os.path.join(curPath, img)) считывает изображение с полученным путем и сохраняет его в переменную curImg. Это позволяет загрузить изображение в формате, понятном для OpenCV, и использовать его для дальнейшей обработки.
15.images.append(curImg) добавляет считанное изображение curImg в список images. Список images предназначен для хранения всех загруженных изображений.
16.classNames.append(cls)добавляет имя класса cls в список classNames. Список classNames предназначен для хранения имен классов или названий директорий, из которых были загружены изображения.

def findEncodings(images):
    encodeList = []
    for img in images:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        #img = cv2.imread(imageFilePath, cv2.IMREAD_COLOR)
        encode = face_recognition.face_encodings(img)[0]
        encodeList.append(encode)
    return encodeList
​
Данный код представляет функцию findEncodings, которая принимает список изображений images в качестве аргумента и возвращает список закодированных лиц, соответствующих этим изображениям.
Внутри функции происходит следующее:
Создается пустой список encodeList, который будет содержать закодированные лица.
Далее, для каждого изображения img в списке images, выполняются следующие действия:
a. img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB): Данная строка кода преобразует изображение из цветового пространства BGR в RGB. Библиотека face_recognition требует изображения в формате RGB для корректного распознавания лиц.
b. encode = face_recognition.face_encodings(img)[0]: Эта строка кода использует библиотеку face_recognition для извлечения кодировки лица из изображения img. Функция face_encodings() возвращает список кодировок всех лиц на изображении, и здесь мы выбираем только первую кодировку и сохраняем ее в переменную encode.
c. encodeList.append(encode): Данная строка кода добавляет закодированное лицо encode в список encodeList.
В конце функции возвращается список encodeList, содержащий все закодированные лица соответствующих изображений.

import pandas as pd
from datetime import datetime
​
# Создайте пустой DataFrame для хранения данных по посещаемости
attendance_data = pd.DataFrame(columns=["Имя", "Дата", "Время", "Отметка"])
​
def markAttendance(name):
    # Получите текущую дату и время
    current_date = datetime.now().strftime("%d-%m-%Y")
    current_time = datetime.now().strftime("%H:%M:%S")
​
    # Добавьте запись в DataFrame
    attendance_data.loc[len(attendance_data)] = [name, current_date, current_time, "Посещаемость отмечена"]
    print(name, "-", current_date," : ", current_time, "  - Посещаемость отмечена")
​
    # Сохраните DataFrame в файл CSV
    attendance_data.to_csv("attendance_data.csv", index=False)
​
Данный код выполняет следующие действия:
import pandas as pd: Этот оператор импортирует библиотеку Pandas, которая предоставляет функциональность для работы с данными, включая создание и манипуляцию с DataFrame (таблицами данных).
from datetime import datetime: Этот оператор импортирует класс datetime из модуля datetime. Он используется для работы с датой и временем.
attendance_data = pd.DataFrame(columns=["Имя", "Время", "Отметка"]): Эта строка кода создает пустой DataFrame с указанными колонками "Имя", "Время" и "Отметка". DataFrame предназначен для хранения данных по посещаемости.
def markAttendance(name):: Это объявление функции markAttendance, которая принимает параметр name - имя человека, для которого будет отмечена посещаемость.
current_time = datetime.datetime.now().strftime("%H:%M:%S"): Эта строка кода получает текущее время с помощью функции datetime.now(), а затем форматирует его в строку в формате часы:минуты:секунды, используя метод strftime(). Результат сохраняется в переменную current_time.
attendance_data.loc[len(attendance_data)] = [name, current_time, "Посещаемость отмечена"]: Эта строка кода добавляет новую запись в DataFrame attendance_data. С помощью метода loc[] указывается индекс новой строки (здесь len(attendance_data) используется для получения следующего доступного индекса), а в квадратных скобках указываются значения для каждой колонки: name, current_time и строка "Посещаемость отмечена".
print(name, "-", current_time, "- Посещаемость отмечена"): Эта строка кода выводит информацию о имени, текущем времени и статусе "Посещаемость отмечена" на консоль.
attendance_data.to_csv("attendance_data.csv", index=False): Эта строка кода сохраняет DataFrame attendance_data в файл CSV с именем "attendance_data.csv". Параметр index=False указывает, чтобы индексы строк не были сохранены в файл.
Таким образом, функция markAttendance() добавляет запись о посещаемости в DataFrame attendance_data, выводит информацию на консоль и сохраняет данные в файл CSV.

encodeListKnown = findEncodings(images)
print("Декодирование закончено")
Декодирование закончено
Данный код выполняет следующие действия:
encodeListKnown = findEncodings(images): Эта строка кода вызывает функцию findEncodings(images) и присваивает возвращаемое значение (список закодированных лиц) переменной encodeListKnown. Функция findEncodings() принимает список изображений images в качестве аргумента и возвращает список закодированных лиц, соответствующих этим изображениям.
print("Декодирование закончено"): Эта строка кода просто выводит сообщение "Декодирование закончено" на консоль. Она служит для информирования о том, что процесс декодирования закончен.
Таким образом, код выполняет декодирование лиц на загруженных изображениях и выводит сообщение о завершении процесса. После выполнения этого кода, список encodeListKnown будет содержать закодированные лица для дальнейшего использования.

import numpy as np
​
# Путь и имя файла для сохранения кодировок
file_path = '/Users/n.a./Downloads/encodeListKnown.npy'
​
# Сохранение кодировок в файл
np.save(file_path, encodeListKnown)
​
print("Кодировки сохранены в файл:", file_path)
​
Кодировки сохранены в файл: /Users/n.a./Downloads/encodeListKnown.npy
Данный код выполняет следующие действия:
import numpy as np: Этот оператор импортирует библиотеку NumPy, которая предоставляет функциональность для работы с массивами и матрицами.
file_path = '/Users/n.a./Downloads/encodeListKnown.npy': В этой строке кода задается путь и имя файла, в котором будут сохранены кодировки лиц. Здесь используется переменная file_path, содержащая полный путь к файлу.
np.save(file_path, encodeListKnown): Эта строка кода использует функцию np.save() из библиотеки NumPy для сохранения списка кодировок лиц encodeListKnown в файл с указанным путем file_path. Функция np.save() сохраняет массивы NumPy в двоичном формате.
print("Кодировки сохранены в файл:", file_path): Эта строка кода выводит сообщение на консоль, уведомляя о том, что кодировки лиц были сохранены в указанный файл.
Таким образом, данный код сохраняет список кодировок лиц encodeListKnown в файл с помощью функции np.save(). Это позволяет сохранить кодировки лиц для дальнейшего использования без необходимости повторного выполнения процесса декодирования.
Так, как мы сохранили список кодировок лиц encodeListKnown, вызываем список из директории

import numpy as np
import face_recognition
import cv2
import os
from datetime import datetime
import os
import numpy as np
​
# Путь и имя файла для загрузки кодировок
file_path = '/Users/n.a./Downloads/encodeListKnown.npy'
​
# Загрузка данных из файла
encodeListKnown = np.load(file_path)
​
# Продолжайте использовать переменную encodeListKnown
​
Данный код выполняет следующие действия:
import numpy as np: Этот оператор импортирует библиотеку NumPy.
import face_recognition: Этот оператор импортирует библиотеку face_recognition, которая используется для распознавания лиц.
import cv2: Этот оператор импортирует библиотеку OpenCV, которая предоставляет функциональность для обработки изображений и видео.
import os: Этот оператор импортирует модуль os, который предоставляет функции для работы с операционной системой.
from datetime import datetime: Этот оператор импортирует класс datetime из модуля datetime для работы с датой и временем.
import os: Этот оператор повторно импортирует модуль os. Обратите внимание, что повторные операторы импорта не оказывают никакого влияния на функциональность кода.
import numpy as np: Этот оператор повторно импортирует библиотеку NumPy. Обратите внимание, что повторные операторы импорта не оказывают никакого влияния на функциональность кода.
file_path = '/Users/n.a./Downloads/encodeListKnown.npy': В этой строке кода задается путь и имя файла, из которого будут загружены кодировки лиц. Здесь используется переменная file_path, содержащая полный путь к файлу.
encodeListKnown = np.load(file_path): Эта строка кода использует функцию np.load() из библиотеки NumPy для загрузки кодировок лиц из указанного файла file_path. Функция np.load() загружает сохраненные массивы NumPy из двоичного файла.
Продолжайте использовать переменную encodeListKnown: После загрузки кодировок лиц в переменную encodeListKnown, вы можете продолжить использовать эту переменную в коде для сравнения или распознавания лиц.
Таким образом, данный код загружает кодировки лиц из указанного файла и позволяет вам продолжить использовать переменную encodeListKnown с уже загруженными кодировками лиц в дальнейшем коде.

from datetime import datetime
​
cap = cv2.VideoCapture(0)
​
while True:
    success, img = cap.read()
    imgS = cv2.resize(img, (0, 0), None, 0.25, 0.25)
    imgS = cv2.cvtColor(imgS, cv2.COLOR_BGR2RGB)
​
    facesCurFrame = face_recognition.face_locations(imgS)
    encodeCurFrame = face_recognition.face_encodings(imgS, facesCurFrame)
    
​
    for encodeFace, faceLoc in zip(encodeCurFrame, facesCurFrame):
        matches = face_recognition.compare_faces(encodeListKnown, encodeFace)
        faceDis = face_recognition.face_distance(encodeListKnown, encodeFace)
        #print(faceDis)
        matchIndex = np.argmin(faceDis)
        
    for encodeFace, faceLoc in zip(encodeCurFrame, facesCurFrame):
        matches = face_recognition.compare_faces(encodeListKnown, encodeFace)
        faceDis = face_recognition.face_distance(encodeListKnown, encodeFace)
        matchIndex = np.argmin(faceDis)
​
        if matches[matchIndex] and faceDis[matchIndex] < 0.95:
​
            name = classNames[matchIndex]
            print(name)
            
           
​
            from datetime import datetime
​
            # Получите текущую дату и время
            current_datetime = datetime.now()
            current_date = current_datetime.strftime("%d-%m-%Y")
            current_time = current_datetime.strftime("%H:%M:%S")
​
​
​
            y1, x2, y2, x1 = faceLoc
            y1, x2, y2, x1 = y1 * 4, x2 * 4, y2 * 4, x1 * 4
            cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)
            cv2.rectangle(img, (x1, y2 - 35), (x2, y2), (0, 255, 0), cv2.FILLED)
            cv2.putText(img, f"{name} - {current_date} {current_time}", (x1 + 6, y2 - 6), cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 255), 2)
​
            markAttendance(name)
​
            # Get the current time
            #current_time = datetime.datetime.now().strftime("%H:%M:%S")
            
            
​
            #y1, x2, y2, x1 = faceLoc
            #y1, x2, y2, x1 = y1 * 4, x2 * 4, y2 * 4, x1 * 4
            #cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)
            #cv2.rectangle(img, (x1, y2 - 35), (x2, y2), (0, 255, 0), cv2.FILLED)
            #cv2.putText(img, f"{name} - {current_time}", (x1 + 6, y2 - 6),cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 255), 2)
            #markAttendance(name)
​
​
    cv2.imshow("WebCam", img)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break
​
Person_9
Person_9 - 11-05-2023  :  13:23:51   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:51   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:51   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:51   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:51   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:51   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:52   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:52   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:52   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:52   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:52   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:52   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:52   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:52   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:53   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:53   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:53   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:53   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:53   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:53   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:53   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:53   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:54   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:55   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:55   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:55   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:55   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:55   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:55   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:55   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:55   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:55   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:56   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:56   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:56   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:56   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:56   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:56   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:56   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:56   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:56   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:57   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:57   - Посещаемость отмечена
Person_9
Person_9 - 11-05-2023  :  13:23:57   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:03   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:03   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:03   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:03   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:04   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:04   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:04   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:05   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:05   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:05   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:05   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:05   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:05   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:05   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:05   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:06   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:06   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:06   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:06   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:06   - Посещаемость отмечена
Person_2
Person_2 - 11-05-2023  :  13:24:06   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:12   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:12   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:12   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:12   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:12   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:12   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:12   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:12   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:12   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:13   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:13   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:13   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:13   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:13   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:13   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:13   - Посещаемость отмечена
Person_7
Person_7 - 11-05-2023  :  13:24:13   - Посещаемость отмечена

Данный код выполняет следующие действия:
​
Импортируется модуль datetime для работы с датой и временем.
​
Захватывается видео с помощью веб-камеры с помощью cv2.VideoCapture(0). Здесь 0 означает, что используется первая
доступная камера.
​
В цикле while True выполняются следующие действия:
​
Читается кадр из видеопотока с помощью cap.read(), и результат сохраняется в переменных success и img.
Изображение img изменяется в размере до 25% и преобразуется в формат RGB.
С помощью face_recognition.face_locations определяются положения лиц на изображении.
С помощью face_recognition.face_encodings вычисляются кодировки лиц на изображении.
В первом цикле for производится итерация по парам encodeFace и faceLoc, используя zip(encodeCurFrame,facesCurFrame).
​
С помощью face_recognition.compare_faces сравниваются кодировки encodeFace с кодировками известных лиц
encodeListKnown.
С помощью face_recognition.face_distance вычисляются расстояния между кодировками encodeFace и encodeListKnown.
С помощью np.argmin находится индекс кодировки с наименьшим расстоянием (самое близкое совпадение).
Во втором цикле for также производится итерация по парам encodeFace и faceLoc.
​
Повторно выполняются операции сравнения кодировок и вычисления расстояний между кодировками.
Проверяется условие matches[matchIndex] and faceDis[matchIndex] < 0.95 для определения совпадения и наличия
достаточно близкого расстояния между кодировками.
Если условие выполняется, то происходит распознавание лица, и имя человека сохраняется в переменную name.
Получается текущее время с помощью datetime.datetime.now().strftime("%H:%M:%S").
​
Используя данные о расположении лица faceLoc, рисуется прямоугольник вокруг лица на изображении img с помощью
cv2.rectangle.
​
Также рисуется прямоугольник для отображения имени и времени с помощью cv2.rectangle и cv2.putText.
Функция markAttendance вызывается для отметки посещаемости человека с именем name.
​
Изображение с нарисованными прямоугольниками и текстом выводится на экран с помощью cv2.imshow("WebCam", img).
​
Программа ожидает нажатия клавиши с помощью cv2.waitKey(1). Если нажат символ "q", то цикл
прерывается с помощью break, и программа завершается.
​
Таким образом, код выполняет непрерывное распознавание лиц в реальном времени с использованием веб-камеры.
Он загружает ранее сохраненные кодировки лиц,сравнивает их с кодировками лиц, обнаруженными на текущем изображении,
и при совпадении выводит имя и текущее время на изображении. Кроме того, он отмечает посещаемость каждого
распознанного человека и сохраняет данные в файл CSV.
